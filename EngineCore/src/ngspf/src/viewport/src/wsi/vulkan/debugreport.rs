//
// Copyright 2018 yvt, all rights reserved.
//
// This source code is a part of Nightingales.
//
use super::ash::{self, extensions, version::*, vk};
use ngsenumflags::BitFlags;
use std::sync::Arc;
use std::{fmt, ptr};

use super::utils::translate_generic_error_unwrap;

/// Debug report provided by validation layers.
///
/// This was formerly a part of NgsGFX Core.
#[derive(Debug, Clone)]
pub struct DebugReport<'a> {
    pub typ: DebugReportType,
    pub message: &'a str,
}

/// Receives `DebugReport`s generated by drivers and validation layers.
pub trait DebugReportHandler: Send + Sync {
    fn log(&self, report: &DebugReport);
}

#[derive(NgsEnumFlags, Copy, Clone, Debug, Hash, PartialEq, Eq)]
#[repr(u32)]
pub enum DebugReportType {
    /// Informational messages that may be handy when debugging an
    /// application.
    Information = 0b00001,

    /// Reports for potentially wrong, but not immediately harmful API usages.
    Warning = 0b00010,

    /// Reports for non-optimal API usages.
    PerformanceWarning = 0b00100,

    /// Reports for usages that may cause undefined results.
    Error = 0b01000,

    /// Diagnostic informations.
    Debug = 0b10000,
}

pub type DebugReportTypeFlags = BitFlags<DebugReportType>;

/// Wraps the interface to the `VK_EXT_debug_report` instance extension.
pub struct DebugReportConduit {
    ext: extensions::DebugReport,
    callbacks: Vec<DebugReportCallback>,
}

impl fmt::Debug for DebugReportConduit {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("DebugReportConduit")
            .field("ext", &())
            .field("callbacks", &())
            .finish()
    }
}

struct DebugReportCallback {
    handle: vk::DebugReportCallbackEXT,
    data: Box<DebugReportCallbackData>,
}

struct DebugReportCallbackData(Arc<DebugReportHandler>, DebugReportType);

impl Drop for DebugReportConduit {
    fn drop(&mut self) {
        for callback in self.callbacks.drain(..) {
            unsafe {
                self.ext
                    .destroy_debug_report_callback_ext(callback.handle, None);
            }
        }
    }
}

unsafe extern "system" fn debug_callback(
    _: vk::DebugReportFlagsEXT,
    _: vk::DebugReportObjectTypeEXT,
    _: vk::uint64_t,
    _: vk::size_t,
    _: vk::int32_t,
    p_layer_prefix: *const vk::c_char,
    p_message: *const vk::c_char,
    p_user_data: *mut vk::c_void,
) -> u32 {
    use std::ffi::CStr;

    let layer_prefix = CStr::from_ptr(p_layer_prefix).to_string_lossy();
    let message = CStr::from_ptr(p_message).to_string_lossy();
    let ref data: DebugReportCallbackData = *(p_user_data as *const _);

    data.0.log(&DebugReport {
        typ: data.1,
        message: &format!("{}: {}", layer_prefix, message),
    });

    vk::VK_TRUE
}

impl DebugReportConduit {
    pub fn new(
        entry: &ash::Entry<V1_0>,
        instance: &ash::Instance<V1_0>,
    ) -> Result<Self, Vec<&'static str>> {
        Ok(Self {
            ext: extensions::DebugReport::new(entry, instance)?,
            callbacks: Vec::new(),
        })
    }

    pub fn add_handler(&mut self, flags: DebugReportTypeFlags, handler: Arc<DebugReportHandler>) {
        for &(typ, vk_typ) in [
            (
                DebugReportType::Information,
                vk::DEBUG_REPORT_INFORMATION_BIT_EXT,
            ),
            (DebugReportType::Warning, vk::DEBUG_REPORT_WARNING_BIT_EXT),
            (
                DebugReportType::PerformanceWarning,
                vk::DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT,
            ),
            (DebugReportType::Error, vk::DEBUG_REPORT_ERROR_BIT_EXT),
            (DebugReportType::Debug, vk::DEBUG_REPORT_DEBUG_BIT_EXT),
        ].iter()
        {
            if flags.contains(typ) {
                self.callbacks.reserve(1);
                let mut data = Box::new(DebugReportCallbackData(Arc::clone(&handler), typ));
                let handle = unsafe {
                    self.ext.create_debug_report_callback_ext(
                        &vk::DebugReportCallbackCreateInfoEXT {
                            s_type: vk::StructureType::DebugReportCallbackCreateInfoExt,
                            p_next: ptr::null(),
                            flags: vk_typ,
                            pfn_callback: debug_callback,
                            p_user_data: &mut *data as *mut DebugReportCallbackData as *mut _,
                        },
                        None,
                    )
                }.map_err(translate_generic_error_unwrap)
                    .unwrap();
                self.callbacks.push(DebugReportCallback { handle, data });
            }
        }
    }
}

use std::sync::Mutex;

/// The debug report handler that outputs messages using `print`.
pub struct PrintDebugReportHandler(Mutex<()>);

impl PrintDebugReportHandler {
    pub fn new() -> Self {
        PrintDebugReportHandler(Mutex::new(()))
    }
}

impl DebugReportHandler for PrintDebugReportHandler {
    fn log(&self, report: &DebugReport) {
        let _ = self.0.lock().unwrap();
        match report.typ {
            DebugReportType::Debug => {
                print!("DEBUG ");
            }
            DebugReportType::Information => {
                print!("INFO  ");
            }
            DebugReportType::Warning => {
                print!("WARN  ");
            }
            DebugReportType::PerformanceWarning => {
                print!("PERF  ");
            }
            DebugReportType::Error => {
                print!("ERROR ");
            }
        }
        println!("{}", report.message);
    }
}

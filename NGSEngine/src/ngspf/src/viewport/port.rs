//
// Copyright 2017 yvt, all rights reserved.
//
// This source code is a part of Nightingales.
//
use std::{any, fmt};
use std::sync::Arc;
use cgmath::Vector2;
use gfx::core::Backend;

use context::PresenterFrame;
use super::WorkspaceDevice;

/// Trait for rendering custom contents to a layer's backing store.
pub trait Port: fmt::Debug + Send + Sync + 'static {
    /// Create a port instance for a specific NgsGFX backend.
    ///
    /// The callee must find an appropriate implementation for the actual
    /// backend by calling `PortCreateContext::downcast_mut` with a known set
    /// of backends.
    ///
    ///     use ngspf::viewport::{Port, PortCreateContext};
    ///     use ngspf::gfx::backends::DefaultBackend;
    ///     #[derive(Debug)]
    ///     struct MyPort;
    ///
    ///     impl Port for MyPort {
    ///         fn make_instance(&self, context: &mut PortCreateContext) {
    ///             if let Some(context) = context.downcast_mut::<DefaultBackend>() {
    ///                 *context.result = Some(panic!("provide instance here"));
    ///             }
    ///         }
    ///     }
    ///
    fn make_instance(&self, context: &mut PortCreateContext);
}

#[derive(Debug)]
pub struct PortCreateContext<'a> {
    pub(super) workspace_device: &'a any::Any,
    pub(super) result: &'a mut any::Any,
}

#[derive(Debug)]
pub struct PortCreateContextWithBackend<'a, B: Backend> {
    pub workspace_device: &'a WorkspaceDevice<B>,
    pub result: &'a mut Option<Arc<PortInstance<B>>>,
}

impl<'a> PortCreateContext<'a> {
    pub fn downcast_mut<B: Backend>(&mut self) -> Option<PortCreateContextWithBackend<B>> {
        if let Some(result) = self.result.downcast_mut() {
            Some(PortCreateContextWithBackend {
                workspace_device: self.workspace_device.downcast_ref().unwrap(),
                result,
            })
        } else {
            None
        }
    }
}

#[derive(Debug)]
pub struct PortRenderContext<'a, B: Backend> {
    pub workspace_device: &'a WorkspaceDevice<B>,

    /// Set this to `true` to continuously update the screen.
    pub schedule_next_frame: bool,

    /// List of command buffers generated by the port and to be submitted later.
    pub command_buffers: Vec<B::CommandBuffer>,

    /// The backing store to render into.
    pub image: &'a B::Image,

    /// The size of the backing store image.
    pub image_extents: Vector2<u32>,
}

pub trait PortInstance<B: Backend>: fmt::Debug + Send + Sync + 'static {
    fn render(&mut self, context: &PortRenderContext<B>, frame: &PresenterFrame);
}

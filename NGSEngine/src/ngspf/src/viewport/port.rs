//
// Copyright 2017 yvt, all rights reserved.
//
// This source code is a part of Nightingales.
//
use std::{any, fmt};
use std::sync::Arc;
use cgmath::Vector2;
use atomic_refcell::AtomicRefCell;
use gfx::core::Backend;

use context::PresenterFrame;
use super::WorkspaceDevice;

/// Trait for rendering custom contents to a layer's backing store.
pub trait Port: fmt::Debug + Send + Sync + 'static {
    /// Create a port instance for a specific NgsGFX backend.
    ///
    /// The callee must find an appropriate implementation for the actual
    /// backend by calling `PortMountContext::downcast_mut` with a known set
    /// of backends.
    ///
    ///     use ngspf::viewport::{Port, PortMountContext};
    ///     use ngspf::gfx::backends::DefaultBackend;
    ///     #[derive(Debug)]
    ///     struct MyPort;
    ///
    ///     impl Port for MyPort {
    ///         fn mount(&self, context: &mut PortMountContext) {
    ///             if let Some(mut context) = context.downcast_mut::<DefaultBackend>() {
    ///                 context.set_instance(panic!("provide instance here"));
    ///             }
    ///         }
    ///     }
    ///
    fn mount(&self, context: &mut PortMountContext);
}

#[derive(Debug)]
pub struct PortMountContext<'a> {
    pub(super) workspace_device: &'a any::Any,
    pub(super) result_instance: &'a mut any::Any,
}

#[derive(Debug)]
pub struct PortMountContextWithBackend<'a, B: Backend> {
    pub(super) workspace_device: &'a WorkspaceDevice<B>,
    pub(super) result_instance: &'a mut Option<Box<PortInstance<B>>>,
}

impl<'a> PortMountContext<'a> {
    pub fn downcast_mut<B: Backend>(&mut self) -> Option<PortMountContextWithBackend<B>> {
        if let Some(result_instance) = self.result_instance.downcast_mut() {
            Some(PortMountContextWithBackend {
                workspace_device: self.workspace_device.downcast_ref().unwrap(),
                result_instance,
            })
        } else {
            None
        }
    }
}

impl<'a, B: Backend> PortMountContextWithBackend<'a, B> {
    pub fn workspace_device(&self) -> &'a WorkspaceDevice<B> {
        self.workspace_device
    }

    pub fn set_instance(&mut self, instance: Box<PortInstance<B>>) {
        *self.result_instance = Some(instance);
    }
}

#[derive(Debug)]
pub struct PortRenderContext<'a, B: Backend> {
    pub workspace_device: &'a WorkspaceDevice<B>,

    /// Set this to `true` to continuously update the screen.
    pub schedule_next_frame: bool,

    /// List of command buffers generated by the port and to be submitted later.
    pub command_buffers: Vec<Arc<AtomicRefCell<B::CommandBuffer>>>,

    /// The backing store to render into.
    pub image: &'a B::Image,

    /// The size of the backing store image.
    pub image_extents: Vector2<u32>,
}

pub trait PortInstance<B: Backend>: fmt::Debug + Send + Sync + 'static {
    fn render(&mut self, context: &PortRenderContext<B>, frame: &PresenterFrame);
}

//
// Copyright 2017 yvt, all rights reserved.
//
// This source code is a part of Nightingales.
//
use std::io::{Read, Seek, SeekFrom, Result, Error, ErrorKind};
use std::ops::Range;
use byteorder::{LE, ReadBytesExt};
use cgmath::{Vector2, Vector3};

use {Terrain, SolidVoxel, ColoredVoxel};

#[cfg_attr(rustfmt, rustfmt_skip)]
static DEFAULT_PALETTE: [u8; 1024] = [
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcc, 0xff, 0xff, 0xff, 0x99, 0xff, 0xff, 0xff, 0x66, 0xff, 0xff, 0xff, 0x33, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xcc, 0xff, 0xff, 0xff, 0xcc, 0xcc, 0xff, 0xff, 0xcc, 0x99, 0xff, 0xff, 0xcc, 0x66, 0xff, 0xff, 0xcc, 0x33, 0xff, 0xff, 0xcc, 0x00, 0xff, 0xff, 0x99, 0xff, 0xff, 0xff, 0x99, 0xcc, 0xff, 0xff, 0x99, 0x99, 0xff,
    0xff, 0x99, 0x66, 0xff, 0xff, 0x99, 0x33, 0xff, 0xff, 0x99, 0x00, 0xff, 0xff, 0x66, 0xff, 0xff, 0xff, 0x66, 0xcc, 0xff, 0xff, 0x66, 0x99, 0xff, 0xff, 0x66, 0x66, 0xff, 0xff, 0x66, 0x33, 0xff, 0xff, 0x66, 0x00, 0xff, 0xff, 0x33, 0xff, 0xff, 0xff, 0x33, 0xcc, 0xff, 0xff, 0x33, 0x99, 0xff, 0xff, 0x33, 0x66, 0xff, 0xff, 0x33, 0x33, 0xff, 0xff, 0x33, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff,
    0xff, 0x00, 0xcc, 0xff, 0xff, 0x00, 0x99, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x33, 0xff, 0xff, 0x00, 0x00, 0xff, 0xcc, 0xff, 0xff, 0xff, 0xcc, 0xff, 0xcc, 0xff, 0xcc, 0xff, 0x99, 0xff, 0xcc, 0xff, 0x66, 0xff, 0xcc, 0xff, 0x33, 0xff, 0xcc, 0xff, 0x00, 0xff, 0xcc, 0xcc, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0xff, 0xcc, 0xcc, 0x99, 0xff, 0xcc, 0xcc, 0x66, 0xff, 0xcc, 0xcc, 0x33, 0xff,
    0xcc, 0xcc, 0x00, 0xff, 0xcc, 0x99, 0xff, 0xff, 0xcc, 0x99, 0xcc, 0xff, 0xcc, 0x99, 0x99, 0xff, 0xcc, 0x99, 0x66, 0xff, 0xcc, 0x99, 0x33, 0xff, 0xcc, 0x99, 0x00, 0xff, 0xcc, 0x66, 0xff, 0xff, 0xcc, 0x66, 0xcc, 0xff, 0xcc, 0x66, 0x99, 0xff, 0xcc, 0x66, 0x66, 0xff, 0xcc, 0x66, 0x33, 0xff, 0xcc, 0x66, 0x00, 0xff, 0xcc, 0x33, 0xff, 0xff, 0xcc, 0x33, 0xcc, 0xff, 0xcc, 0x33, 0x99, 0xff,
    0xcc, 0x33, 0x66, 0xff, 0xcc, 0x33, 0x33, 0xff, 0xcc, 0x33, 0x00, 0xff, 0xcc, 0x00, 0xff, 0xff, 0xcc, 0x00, 0xcc, 0xff, 0xcc, 0x00, 0x99, 0xff, 0xcc, 0x00, 0x66, 0xff, 0xcc, 0x00, 0x33, 0xff, 0xcc, 0x00, 0x00, 0xff, 0x99, 0xff, 0xff, 0xff, 0x99, 0xff, 0xcc, 0xff, 0x99, 0xff, 0x99, 0xff, 0x99, 0xff, 0x66, 0xff, 0x99, 0xff, 0x33, 0xff, 0x99, 0xff, 0x00, 0xff, 0x99, 0xcc, 0xff, 0xff,
    0x99, 0xcc, 0xcc, 0xff, 0x99, 0xcc, 0x99, 0xff, 0x99, 0xcc, 0x66, 0xff, 0x99, 0xcc, 0x33, 0xff, 0x99, 0xcc, 0x00, 0xff, 0x99, 0x99, 0xff, 0xff, 0x99, 0x99, 0xcc, 0xff, 0x99, 0x99, 0x99, 0xff, 0x99, 0x99, 0x66, 0xff, 0x99, 0x99, 0x33, 0xff, 0x99, 0x99, 0x00, 0xff, 0x99, 0x66, 0xff, 0xff, 0x99, 0x66, 0xcc, 0xff, 0x99, 0x66, 0x99, 0xff, 0x99, 0x66, 0x66, 0xff, 0x99, 0x66, 0x33, 0xff,
    0x99, 0x66, 0x00, 0xff, 0x99, 0x33, 0xff, 0xff, 0x99, 0x33, 0xcc, 0xff, 0x99, 0x33, 0x99, 0xff, 0x99, 0x33, 0x66, 0xff, 0x99, 0x33, 0x33, 0xff, 0x99, 0x33, 0x00, 0xff, 0x99, 0x00, 0xff, 0xff, 0x99, 0x00, 0xcc, 0xff, 0x99, 0x00, 0x99, 0xff, 0x99, 0x00, 0x66, 0xff, 0x99, 0x00, 0x33, 0xff, 0x99, 0x00, 0x00, 0xff, 0x66, 0xff, 0xff, 0xff, 0x66, 0xff, 0xcc, 0xff, 0x66, 0xff, 0x99, 0xff,
    0x66, 0xff, 0x66, 0xff, 0x66, 0xff, 0x33, 0xff, 0x66, 0xff, 0x00, 0xff, 0x66, 0xcc, 0xff, 0xff, 0x66, 0xcc, 0xcc, 0xff, 0x66, 0xcc, 0x99, 0xff, 0x66, 0xcc, 0x66, 0xff, 0x66, 0xcc, 0x33, 0xff, 0x66, 0xcc, 0x00, 0xff, 0x66, 0x99, 0xff, 0xff, 0x66, 0x99, 0xcc, 0xff, 0x66, 0x99, 0x99, 0xff, 0x66, 0x99, 0x66, 0xff, 0x66, 0x99, 0x33, 0xff, 0x66, 0x99, 0x00, 0xff, 0x66, 0x66, 0xff, 0xff,
    0x66, 0x66, 0xcc, 0xff, 0x66, 0x66, 0x99, 0xff, 0x66, 0x66, 0x66, 0xff, 0x66, 0x66, 0x33, 0xff, 0x66, 0x66, 0x00, 0xff, 0x66, 0x33, 0xff, 0xff, 0x66, 0x33, 0xcc, 0xff, 0x66, 0x33, 0x99, 0xff, 0x66, 0x33, 0x66, 0xff, 0x66, 0x33, 0x33, 0xff, 0x66, 0x33, 0x00, 0xff, 0x66, 0x00, 0xff, 0xff, 0x66, 0x00, 0xcc, 0xff, 0x66, 0x00, 0x99, 0xff, 0x66, 0x00, 0x66, 0xff, 0x66, 0x00, 0x33, 0xff,
    0x66, 0x00, 0x00, 0xff, 0x33, 0xff, 0xff, 0xff, 0x33, 0xff, 0xcc, 0xff, 0x33, 0xff, 0x99, 0xff, 0x33, 0xff, 0x66, 0xff, 0x33, 0xff, 0x33, 0xff, 0x33, 0xff, 0x00, 0xff, 0x33, 0xcc, 0xff, 0xff, 0x33, 0xcc, 0xcc, 0xff, 0x33, 0xcc, 0x99, 0xff, 0x33, 0xcc, 0x66, 0xff, 0x33, 0xcc, 0x33, 0xff, 0x33, 0xcc, 0x00, 0xff, 0x33, 0x99, 0xff, 0xff, 0x33, 0x99, 0xcc, 0xff, 0x33, 0x99, 0x99, 0xff,
    0x33, 0x99, 0x66, 0xff, 0x33, 0x99, 0x33, 0xff, 0x33, 0x99, 0x00, 0xff, 0x33, 0x66, 0xff, 0xff, 0x33, 0x66, 0xcc, 0xff, 0x33, 0x66, 0x99, 0xff, 0x33, 0x66, 0x66, 0xff, 0x33, 0x66, 0x33, 0xff, 0x33, 0x66, 0x00, 0xff, 0x33, 0x33, 0xff, 0xff, 0x33, 0x33, 0xcc, 0xff, 0x33, 0x33, 0x99, 0xff, 0x33, 0x33, 0x66, 0xff, 0x33, 0x33, 0x33, 0xff, 0x33, 0x33, 0x00, 0xff, 0x33, 0x00, 0xff, 0xff,
    0x33, 0x00, 0xcc, 0xff, 0x33, 0x00, 0x99, 0xff, 0x33, 0x00, 0x66, 0xff, 0x33, 0x00, 0x33, 0xff, 0x33, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xcc, 0xff, 0x00, 0xff, 0x99, 0xff, 0x00, 0xff, 0x66, 0xff, 0x00, 0xff, 0x33, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xcc, 0xff, 0xff, 0x00, 0xcc, 0xcc, 0xff, 0x00, 0xcc, 0x99, 0xff, 0x00, 0xcc, 0x66, 0xff, 0x00, 0xcc, 0x33, 0xff,
    0x00, 0xcc, 0x00, 0xff, 0x00, 0x99, 0xff, 0xff, 0x00, 0x99, 0xcc, 0xff, 0x00, 0x99, 0x99, 0xff, 0x00, 0x99, 0x66, 0xff, 0x00, 0x99, 0x33, 0xff, 0x00, 0x99, 0x00, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xcc, 0xff, 0x00, 0x66, 0x99, 0xff, 0x00, 0x66, 0x66, 0xff, 0x00, 0x66, 0x33, 0xff, 0x00, 0x66, 0x00, 0xff, 0x00, 0x33, 0xff, 0xff, 0x00, 0x33, 0xcc, 0xff, 0x00, 0x33, 0x99, 0xff,
    0x00, 0x33, 0x66, 0xff, 0x00, 0x33, 0x33, 0xff, 0x00, 0x33, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xcc, 0xff, 0x00, 0x00, 0x99, 0xff, 0x00, 0x00, 0x66, 0xff, 0x00, 0x00, 0x33, 0xff, 0xee, 0x00, 0x00, 0xff, 0xdd, 0x00, 0x00, 0xff, 0xbb, 0x00, 0x00, 0xff, 0xaa, 0x00, 0x00, 0xff, 0x88, 0x00, 0x00, 0xff, 0x77, 0x00, 0x00, 0xff, 0x55, 0x00, 0x00, 0xff, 0x44, 0x00, 0x00, 0xff,
    0x22, 0x00, 0x00, 0xff, 0x11, 0x00, 0x00, 0xff, 0x00, 0xee, 0x00, 0xff, 0x00, 0xdd, 0x00, 0xff, 0x00, 0xbb, 0x00, 0xff, 0x00, 0xaa, 0x00, 0xff, 0x00, 0x88, 0x00, 0xff, 0x00, 0x77, 0x00, 0xff, 0x00, 0x55, 0x00, 0xff, 0x00, 0x44, 0x00, 0xff, 0x00, 0x22, 0x00, 0xff, 0x00, 0x11, 0x00, 0xff, 0x00, 0x00, 0xee, 0xff, 0x00, 0x00, 0xdd, 0xff, 0x00, 0x00, 0xbb, 0xff, 0x00, 0x00, 0xaa, 0xff,
    0x00, 0x00, 0x88, 0xff, 0x00, 0x00, 0x77, 0xff, 0x00, 0x00, 0x55, 0xff, 0x00, 0x00, 0x44, 0xff, 0x00, 0x00, 0x22, 0xff, 0x00, 0x00, 0x11, 0xff, 0xee, 0xee, 0xee, 0xff, 0xdd, 0xdd, 0xdd, 0xff, 0xbb, 0xbb, 0xbb, 0xff, 0xaa, 0xaa, 0xaa, 0xff, 0x88, 0x88, 0x88, 0xff, 0x77, 0x77, 0x77, 0xff, 0x55, 0x55, 0x55, 0xff, 0x44, 0x44, 0x44, 0xff, 0x22, 0x22, 0x22, 0xff, 0x11, 0x11, 0x11, 0xff
];

#[derive(Debug)]
struct Chunk {
    id: [u8; 4],
    contents_range: Range<u64>,
    contents_size: u32,
    children_size: u32,
    children: Vec<Chunk>,
}

impl Chunk {
    fn load<T: Read + Seek>(reader: &mut T) -> Result<Self> {
        let mut id = [0; 4];
        reader.read_exact(&mut id)?;
        let contents_size = reader.read_u32::<LE>()?;
        let children_size = reader.read_u32::<LE>()?;
        let mut children = Vec::new();
        let mut children_read = 0u32;
        while children_read < children_size {
            let child = Self::load(reader)?;
            children_read += child.contents_size + child.children_size + 12;
            children.push(child);
        }

        let contents_start = reader.seek(SeekFrom::Current(0))?;
        let contents_end = reader.seek(SeekFrom::Current(contents_size as i64))?;

        Ok(Self {
            id,
            contents_range: contents_start..contents_end,
            contents_size,
            children_size,
            children,
        })
    }
}

/// Load a `Terrain` from a [MagicaVoxel .vox file data].
///
/// [MagicaVoxel .vox file data]: https://github.com/ephtracy/voxel-model/blob/master/MagicaVoxel-file-format-vox.txt
pub fn from_magicavoxel<T: Read + Seek>(reader: &mut T) -> Result<Terrain> {
    let mut magic = [0; 4];
    reader.read_exact(&mut magic)?;
    if "VOX ".as_bytes() != magic {
        return Err(Error::new(ErrorKind::Other, "invalid magic"));
    }

    let _version = reader.read_u32::<LE>()?;
    // FIXME: how are we supposed to check the version number?

    let main: Chunk = Chunk::load(reader)?;

    let size_chunk = main.children.iter().find(|c| "SIZE".as_bytes() == c.id);
    let xyzi_chunk = main.children.iter().find(|c| "XYZI".as_bytes() == c.id);
    let rgba_chunk = main.children.iter().find(|c| "RGBA".as_bytes() == c.id);

    // Read the extents
    let size: Vector3<usize> = {
        let chunk: &Chunk = size_chunk.ok_or(Error::new(
            ErrorKind::Other,
            "chunk SIZE is missing",
        ))?;
        reader.seek(SeekFrom::Start(chunk.contents_range.start))?;
        if chunk.contents_size < 12 {
            return Err(Error::new(ErrorKind::Other, "chunk SIZE is too short"));
        }
        Vector3::new(
            reader.read_u32::<LE>()?,
            reader.read_u32::<LE>()?,
            reader.read_u32::<LE>()?,
        ).cast()
    };

    if size.x == 0 || size.y == 0 || size.z == 0 ||
        size.x
            .checked_mul(size.y)
            .and_then(|v| v.checked_mul(size.z))
            .is_none()
    {
        return Err(Error::new(ErrorKind::Other, "size is too large"));
    }

    // Read the palette
    let mut palette = DEFAULT_PALETTE.clone();
    if let Some(chunk) = rgba_chunk {
        reader.seek(SeekFrom::Start(chunk.contents_range.start))?;
        if chunk.contents_size < 1020 {
            return Err(Error::new(ErrorKind::Other, "chunk RGBA is too short"));
        }
        reader.read_exact(&mut palette[4..1024])?;
    }

    // Read the voxel data
    let mut dense_rows = vec![vec![None; size.z]; size.x * size.y];
    {
        let chunk: &Chunk = xyzi_chunk.ok_or(Error::new(
            ErrorKind::Other,
            "chunk XYZI is missing",
        ))?;
        if chunk.contents_size < 4 {
            return Err(Error::new(ErrorKind::Other, "chunk XYZI is too short"));
        }
        reader.seek(SeekFrom::Start(chunk.contents_range.start))?;
        let num_voxels = reader.read_u32::<LE>()?;
        if (chunk.contents_size - 4) / 4 < num_voxels {
            return Err(Error::new(ErrorKind::Other, "chunk XYZI is too short"));
        }

        let mut buf = [0; 4];
        for _ in 0..num_voxels {
            reader.read_exact(&mut buf)?;

            let x = buf[0] as usize;
            let y = buf[1] as usize;
            let z = buf[2] as usize;
            let pal = buf[3] as usize;
            if x >= size.x || y >= size.y || z >= size.z {
                return Err(Error::new(ErrorKind::Other, "voxel out of bounds"));
            }

            let color = ColoredVoxel::from_values(
                [palette[pal * 4], palette[pal * 4 + 1], palette[pal * 4 + 2]],
                pal as u8,
            );

            dense_rows[x + y * size.x][z] = Some(SolidVoxel::Colored(color));
        }
    }

    // Create `Terrain`
    let mut t = Terrain::new(size);
    for y in 0..size.y {
        for x in 0..size.x {
            t.get_row_mut(Vector2::new(x, y))
                .unwrap()
                .update_with(dense_rows[x + y * size.x].drain(..))
                .unwrap();
        }
    }

    Ok(t)
}
